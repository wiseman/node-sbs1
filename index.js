// node-sbs1
//
// John Wiseman <jjwiseman@gmail.com> @lemonodor
// Copyright 2013

var events = require('events');
var net = require('net');
var readline = require('readline');
var sbs1 = exports;
var util = require('util');

exports.MessageType = {
  // Generated when the user changes the selected aircraft in
  // BaseStation.
  SELECTION_CHANGE: 'SEL',
  // Generated when an aircraft being tracked sets or changes its
  // callsign.
  NEW_ID: 'ID',
  // Generated when the SBS picks up a signal for an aircraft that it
  // isn't currently tracking,
  NEW_AIRCRAFT: 'AIR',
  // Generated when an aircraft's status changes according to the
  // time-out values in the SBS1 Data Settings menu.
  STATUS_CHANGE: 'STA',
  // Generated when the user double-clicks (or presses return) on an
  // aircraft (i.e. to bring up the aircraft details window).
  CLICK: 'CLK',
  // Generated by the aircraft. There are eight different MSG
  // transmission types, see `TransmissionType`.
  TRANSMISSION: 'MSG'
};


// ## Transmission Types
//
// Transmission messages (MSG) from aircraft may be one of eight types
// (ES = Extended Squitter, DF = Downlink Format, BDS = B-Definition
// Subfield).
//
// |Type|Description                     |Spec          |
// |----|--------------------------------|--------------|
// | 1  | ES identification and category | DF17 BDS 0,8 |
// | 2  | ES surface position message    | DF17 BDS 0,6 |
// | 3  | ES airborne position message   | DF17 BDS 0,5 |
// | 4  | ES airborne velocity message   | DF17 BDS 0,9 |
// | 5  | Surveillance alt message       | DF4, DF20    |
// | 6  | Surveillance ID message        | DF5, DF21    |
// | 7  | Air-to-air message             | DF16         |
// | 8  | All call reply                 | DF11         |

exports.TransmissionType = {
  ES_IDENT_AND_CATEGORY: 1,
  // Triggered by the nose gear squat switch.
  ES_SURFACE_POS: 2,
  ES_AIRBORNE_POS: 3,
  ES_AIRBORNE_VEL: 4,
  // Triggered by ground radar. Not CRC secured. MSG,5 will only be
  // output if the aircraft has previously sent a MSG,1, 2, 3, 4 or 8
  // signal.
  SURVEILLANCE_ALT: 5,
  // Triggered by ground radar. Not CRC secured. MSG,5 will only be
  // output if the aircraft has previously sent a MSG,1, 2, 3, 4 or 8
  // signal.
  SURVEILLANCE_ID: 6,
  // Triggered by TCAS.
  AIR_TO_AIR: 7,
  // Broadcast but also triggered by ground radar.
  ALL_CALL_REPLY: 8
};


// ## Parsing messages
//
// We do basic data type conversion (parsing into integers, floats,
// etc.).
//
// Fields that are empty in the original message--an empty string
// between commas but actually present in the message--are turned into
// `null`.  Fields that are not present in a message--for example,
// field #23 in a message that only contains 12 fields--are turned
// into `undefined`.

exports.parseSbs1Message = function(s) {
  var parts = s.split(',');
  var m = new sbs1.SBS1Message(parts);
  return m;
};

exports.SBS1Message = function(parts) {
  // Replace empty strings (,,) with nulls.
  parts = parts.map(function (e) {
    if (e === '') {
      return null;
    } else {
      return e;
    }
    });
  this.message_type = parts[0];
  this.transmission_type = sbs1_value_to_int(parts[1]);
  // Validate transmission (MSG) messages.
  if (this.message_type == sbs1.MessageType.TRANSMISSION_TYPE &&
      this.transmission_type < 1 || this.transmission_type > 8) {
    throw new Error('Unknown message type: ' + parts[1]);
  }
  this.session_id = parts[2];
  this.aircraft_id = parts[3];
  this.hex_ident = parts[4];
  this.flight_id = parts[5];
  this.generated_date = parts[6];
  this.generated_time = parts[7];
  this.logged_date = parts[8];
  this.logged_time = parts[9];
  this.callsign = parts[10];
  this.altitude = sbs1_value_to_int(parts[11]);
  this.ground_speed = sbs1_value_to_int(parts[12]);
  this.track = sbs1_value_to_int(parts[13]);
  this.lat = sbs1_value_to_float(parts[14]);
  this.lon = sbs1_value_to_float(parts[15]);
  this.vertical_rate = sbs1_value_to_int(parts[16]);
  this.squawk = parts[17];
  this.alert = sbs1_value_to_bool(parts[18]);
  this.emergency = sbs1_value_to_bool(parts[19]);
  this.spi = sbs1_value_to_bool(parts[20]);
  this.is_on_ground = sbs1_value_to_bool(parts[21]);
};


// Parse the `generated_date` and `generated_time` fields into a
// `Date`.
exports.SBS1Message.prototype.generated_timestamp = function() {
  return new Date(this.generated_date + ' ' + this.generated_time);
};


// Parse the `logged_date` and `logged_time` fields into a
// `Date`.
exports.SBS1Message.prototype.logged_timestamp = function() {
  return new Date(this.logged_date + ' ' + this.logged_time);
};


// Convert a value into undefined, null or a boolean.
function sbs1_value_to_bool(v) {
  if (v === undefined || v === null) {
    return v;
  } else {
    return v !== '0';
  }
}


// Convert a value into undefined, null or an integer.
function sbs1_value_to_int(v) {
  if (v === undefined || v === null) {
    return v;
  } else {
    return parseInt(v, 10);
  }
}


// Convert a value into undefined, null or a float.
function sbs1_value_to_float(v) {
  if (v === undefined || v === null) {
    return v;
  } else {
    return parseFloat(v);
  }
}

// # Emitting Sbs1 strings

exports.stringify = function(m) {
  return m.stringify();
};

exports.SBS1Message.prototype.stringify = function() {
  var parts = [
    this.message_type,
    this.transmission_type, // int_to_sbs1_value
    this.session_id,
    this.aircraft_id,
    this.hex_ident,
    this.flight_id,
    this.generated_date,
    this.generated_time,
    this.logged_date,
    this.logged_time,
    this.callsign,
    this.altitude, // int_to_sbs1_value
    this.ground_speed, // int_to_sbs1_value
    this.track, // int_to_sbs1_value
    this.lat, // float_to_sbs1_value
    this.lon, // float_to_sbs1_value
    this.vertical_rate, // int_to_sbs1_value
    this.squawk,
    bool_to_sbs1_value(this.alert),
    bool_to_sbs1_value(this.emergency),
    bool_to_sbs1_value(this.spi),
    bool_to_sbs1_value(this.is_on_ground),
  ];
  // Replace nulls with empty strings
  parts = parts.map(function (e) {
    if (e === null) {
      return '';
    } else {
      return e;
    }
  });
  return parts.join(',');
  // I've commented out the part to remove empty fields at the end of the list
  // due to asserts in the tests differentiating between null and undefined
  // .replace(/(,0?)*$/,'');
};

function bool_to_sbs1_value(v) {
  if (v === undefined || v === null) {
    return v;
  } else {
    return v?'1':'0';
  }
}

// # TCP client

exports.createClient = function(options) {
  var client = new sbs1.Client(options);
  return client;
};


exports.Client = function(options) {
  events.EventEmitter.call(this);
  options = options || {};
  var host = options.host || 'localhost';
  var port = options.port || 30003;
  this.socket = net.connect(
    {
      host: host,
      port: port
    },
    function() {
      console.log('Connected to SBS1 messages at ' +
                  host + ':' + port);
    });
  this.socket.on('error', this.emitError.bind(this));
  this.socket_rl = readline.createInterface({
    input: this.socket,
    output: '/dev/null'});
  this.socket_rl.on('line', this.parseMessage_.bind(this));
};
util.inherits(exports.Client, events.EventEmitter);

exports.Client.prototype.parseMessage_ = function(line) {
  var msg = sbs1.parseSbs1Message(line);
  this.emit('message', msg);
};

exports.Client.prototype.emitError = function(err) {
  this.emit('error', err);
};
